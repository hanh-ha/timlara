{"ast":null,"code":"var _s = $RefreshSig$(),\n    _s2 = $RefreshSig$();\n\nimport moment from 'moment';\nimport _ from 'lodash';\nimport { useEffect, useState, useRef } from 'react';\nexport function isNumeric(value) {\n  return /^-{0,1}\\d+$/.test(value);\n}\nexport function isString(str) {\n  let isStr = false;\n\n  if (str && typeof str === 'string') {\n    isStr = true;\n  }\n\n  return isStr;\n}\nexport const isEmailValid = function (str) {\n  let emailValid = false;\n\n  if (isString(str)) {\n    if (str.match(/[a-z0-9_+\\-.]+@[a-z0-9_\\-.]+\\.[a-z]+/i)) {\n      emailValid = true;\n    }\n  }\n\n  return emailValid;\n};\nexport function buildFormData(formData, data, parentKey) {\n  if (data && typeof data === 'object' && !(data instanceof Date) && !(data instanceof File)) {\n    if (Array.isArray(data)) {\n      formData.append(parentKey, data);\n    } else {\n      Object.keys(data).forEach(key => {\n        const fieldKey = isNumeric(key) ? '[]' : `[${key}]`;\n        buildFormData(formData, data[key], parentKey ? `${parentKey}${fieldKey}` : key);\n      });\n    }\n  } else {\n    const value = data == null ? '' : data;\n    formData.append(parentKey, value);\n  }\n}\nexport function objectToFormData(data) {\n  const formData = new FormData();\n  buildFormData(formData, data);\n  return formData;\n}\nexport const formatSqlDate = (date, noTime) => {\n  if (!date) return '';\n\n  if (!noTime) {\n    return moment(date, 'YYYY-MM-DD HH:mm:ss').format('DD/MM/YYYY HH:mm');\n  }\n\n  return moment(date, 'YYYY-MM-DD HH:mm:ss').format('DD/MM/YYYY');\n};\nexport const useDebounce = (value, delay) => {\n  _s();\n\n  // State and setters for debounced value\n  const [debouncedValue, setDebouncedValue] = useState(value);\n  useEffect(() => {\n    // Update debounced value after delay\n    const handler = setTimeout(() => {\n      setDebouncedValue(value);\n    }, delay); // Cancel the timeout if value changes (also on delay change or unmount)\n    // This is how we prevent debounced value from updating if value is changed ...\n    // .. within the delay period. Timeout gets cleared and restarted.\n\n    return () => {\n      clearTimeout(handler);\n    };\n  }, [value, delay] // Only re-call effect if value or delay changes\n  );\n  return debouncedValue;\n};\n\n_s(useDebounce, \"KDuPAtDOgxm8PU6legVJOb3oOmA=\");\n\nexport const checkAccessParent = (accessible, mod) => {\n  if (!accessible) {\n    return true;\n  }\n\n  if (accessible[mod]) {\n    if (!accessible[mod].length) {\n      return false;\n    } else {\n      return true;\n    }\n  } else {\n    return false;\n  }\n};\nexport const checkAccess = (accessible, mod, action = 'view') => {\n  if (!accessible) {\n    return true;\n  }\n\n  if (accessible[mod]) {\n    if (_.indexOf(accessible[mod], action) === -1) {\n      return false;\n    } else {\n      return true;\n    }\n  } else {\n    return false;\n  }\n};\nexport const usePrevious = value => {\n  _s2();\n\n  const ref = useRef();\n  useEffect(() => {\n    ref.current = value;\n  }, [value]); // Only re-run if value changes\n\n  return ref.current;\n};\n\n_s2(usePrevious, \"8uVE59eA/r6b92xF80p7sH8rXLk=\");\n\nexport const timer = seconds => {\n  let min = '00';\n  let sec = seconds < 10 ? '0' + String(seconds) : String(seconds);\n\n  if (seconds >= 60) {\n    const secs = seconds % 60;\n    sec = secs < 10 ? '0' + String(secs) : String(secs);\n    const mins = Math.floor(seconds / 60);\n    min = mins < 10 ? '0' + String(mins) : String(mins);\n  }\n\n  return min + ':' + sec;\n};","map":{"version":3,"sources":["/var/www/timlara-admin-reactjs/src/helpers/index.ts"],"names":["moment","_","useEffect","useState","useRef","isNumeric","value","test","isString","str","isStr","isEmailValid","emailValid","match","buildFormData","formData","data","parentKey","Date","File","Array","isArray","append","Object","keys","forEach","key","fieldKey","objectToFormData","FormData","formatSqlDate","date","noTime","format","useDebounce","delay","debouncedValue","setDebouncedValue","handler","setTimeout","clearTimeout","checkAccessParent","accessible","mod","length","checkAccess","action","indexOf","usePrevious","ref","current","timer","seconds","min","sec","String","secs","mins","Math","floor"],"mappings":"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","sourcesContent":["import moment from 'moment';\nimport _ from 'lodash';\nimport { useEffect, useState, useRef } from 'react';\n\nexport function isNumeric(value: any) {\n\treturn /^-{0,1}\\d+$/.test(value);\n}\nexport function isString(str: any) {\n\tlet isStr = false;\n\tif (str && typeof str === 'string') {\n\t\tisStr = true;\n\t}\n\treturn isStr;\n}\nexport const isEmailValid = function (str: any) {\n\tlet emailValid = false;\n\tif (isString(str)) {\n\t\tif (str.match(/[a-z0-9_+\\-.]+@[a-z0-9_\\-.]+\\.[a-z]+/i)) {\n\t\t\temailValid = true;\n\t\t}\n\t}\n\treturn emailValid;\n};\nexport function buildFormData(formData: any, data: any, parentKey?: string) {\n\tif (data && typeof data === 'object' && !(data instanceof Date) && !(data instanceof File)) {\n\t\tif (Array.isArray(data)) {\n\t\t\tformData.append(parentKey, data);\n\t\t} else {\n\t\t\tObject.keys(data).forEach((key) => {\n\t\t\t\tconst fieldKey = isNumeric(key) ? '[]' : `[${key}]`;\n\t\t\t\tbuildFormData(formData, data[key], parentKey ? `${parentKey}${fieldKey}` : key);\n\t\t\t});\n\t\t}\n\t} else {\n\t\tconst value = data == null ? '' : data;\n\t\tformData.append(parentKey, value);\n\t}\n}\n\nexport function objectToFormData(data: any) {\n\tconst formData = new FormData();\n\tbuildFormData(formData, data);\n\treturn formData;\n}\n\nexport const formatSqlDate = (date: string, noTime?: boolean): string => {\n\tif (!date) return '';\n\tif (!noTime) {\n\t\treturn moment(date, 'YYYY-MM-DD HH:mm:ss').format('DD/MM/YYYY HH:mm');\n\t}\n\treturn moment(date, 'YYYY-MM-DD HH:mm:ss').format('DD/MM/YYYY');\n};\n\nexport const useDebounce = (value: any, delay: number) => {\n\t// State and setters for debounced value\n\tconst [debouncedValue, setDebouncedValue] = useState(value);\n\n\tuseEffect(\n\t\t() => {\n\t\t\t// Update debounced value after delay\n\t\t\tconst handler = setTimeout(() => {\n\t\t\t\tsetDebouncedValue(value);\n\t\t\t}, delay);\n\n\t\t\t// Cancel the timeout if value changes (also on delay change or unmount)\n\t\t\t// This is how we prevent debounced value from updating if value is changed ...\n\t\t\t// .. within the delay period. Timeout gets cleared and restarted.\n\t\t\treturn () => {\n\t\t\t\tclearTimeout(handler);\n\t\t\t};\n\t\t},\n\t\t[value, delay], // Only re-call effect if value or delay changes\n\t);\n\n\treturn debouncedValue;\n};\n\nexport const checkAccessParent = (accessible: any, mod: string) => {\n\tif (!accessible) {\n\t\treturn true;\n\t}\n\tif (accessible[mod]) {\n\t\tif (!accessible[mod].length) {\n\t\t\treturn false;\n\t\t} else {\n\t\t\treturn true;\n\t\t}\n\t} else {\n\t\treturn false;\n\t}\n};\n\nexport const checkAccess = (accessible: any, mod: string, action = 'view') => {\n\tif (!accessible) {\n\t\treturn true;\n\t}\n\tif (accessible[mod]) {\n\t\tif (_.indexOf(accessible[mod], action) === -1) {\n\t\t\treturn false;\n\t\t} else {\n\t\t\treturn true;\n\t\t}\n\t} else {\n\t\treturn false;\n\t}\n};\n\nexport const usePrevious = (value: any) => {\n\tconst ref = useRef();\n\n\tuseEffect(() => {\n\t\tref.current = value;\n\t}, [value]); // Only re-run if value changes\n\n\treturn ref.current;\n};\n\nexport const timer = (seconds: number): string => {\n\tlet min = '00';\n\tlet sec = seconds < 10 ? '0' + String(seconds) : String(seconds);\n\tif (seconds >= 60) {\n\t\tconst secs = seconds % 60;\n\t\tsec = secs < 10 ? '0' + String(secs) : String(secs);\n\t\tconst mins = Math.floor(seconds / 60);\n\t\tmin = mins < 10 ? '0' + String(mins) : String(mins);\n\t}\n\treturn min + ':' + sec;\n};\n"]},"metadata":{},"sourceType":"module"}